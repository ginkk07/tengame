<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>åœˆåéŠæˆ² - path251231f1</title>
    <style>
        /* --- åŸºç¤ CSS è®Šæ•¸èˆ‡å…¨åŸŸè¨­å®š --- */
        :root { 
            --primary-color: #4a90e2; 
            --secondary-color: #27ae60; 
            --bg-color: #f0f4f8; 
            --text-color: #2c3e50; 
        }
        
        /* é–å®šæ‰‹æ©Ÿæ‰‹å‹¢ï¼šç¦æ­¢é¸å–ã€ç³»çµ±é¸å–®ï¼Œä¸¦å„ªåŒ–è§¸æ§åæ‡‰ */
        * { 
            -webkit-tap-highlight-color: transparent; 
            user-select: none; 
            -webkit-user-select: none; 
            touch-action: manipulation; 
        }

        body { 
            font-family: 'PingFang TC', 'Microsoft JhengHei', sans-serif; 
            background-color: var(--bg-color);
            margin: 0; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            color: var(--text-color); 
            overscroll-behavior-y: contain; /* é˜²æ­¢æ‰‹æ©Ÿä¸‹æ‹‰é‡æ–°æ•´ç† */
            overflow: hidden; 
        }

        /* ä»‹é¢è¦–çª— (Screen) åŸºç¤æ¨£å¼ */
        .screen { 
            display: none; 
            flex-direction: column; 
            align-items: center; 
            background: white; 
            padding: 25px; 
            border-radius: 24px; 
            box-shadow: 0 10px 40px rgba(0,0,0,0.1); 
            width: 92%; 
            max-width: 450px; 
            text-align: center; 
            box-sizing: border-box; 
        }

        .screen.active { display: flex; }

        h1 { font-size: 32px; margin: 0 0 15px 0; color: var(--primary-color); }

        /* è¼¸å…¥æ¡†èˆ‡é€šç”¨æŒ‰éˆ•æ¨£å¼ */
        input { 
            padding: 10px; 
            font-size: 16px; 
            border: 2px solid #e1e8ed; 
            border-radius: 12px; 
            width: 180px; 
            text-align: center; 
            outline: none; 
            user-select: auto; 
            -webkit-user-select: auto; 
        }

        .btn { 
            padding: 12px 0; 
            font-size: 16px; 
            margin: 6px 0; 
            border: none; 
            border-radius: 50px; 
            cursor: pointer; 
            width: 180px; 
            font-weight: bold; 
            transition: transform 0.1s; 
        }
        .btn:active { transform: scale(0.95); }
        .btn-start { background: var(--secondary-color); color: white; }
        .btn-rank { background: var(--primary-color); color: white; }
        .btn-upload { background: #f39c12; color: white; }
        .btn-upload:disabled { background: #ccc; cursor: not-allowed; }
        .btn-back { background: #95a5a6; color: white; }

        /* ğŸ’¡ éŠæˆ²ä¸­é ‚éƒ¨æ¨™é¡Œåˆ— (Score / Time / Gear) */
        .game-header { 
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            width: 100%; 
            margin-bottom: 10px; 
            font-size: 18px; 
            font-weight: bold; 
        }
        
        /* âš™ï¸ Gear æŒ‰éˆ•æ¨£å¼ */
        .gear-btn { font-size: 24px; cursor: pointer; color: #7f8c8d; transition: color 0.2s; padding: 0 5px; }
        .gear-btn:hover { color: var(--primary-color); }

        #game-canvas-container { background: #eee; padding: 4px; border-radius: 12px; }
        
        /* ç•«å¸ƒè¨­å®šï¼š10x16 ç›´å¼ä½ˆå±€ */
        canvas { 
            background: #fff; 
            border-radius: 8px; 
            display: block; 
            touch-action: none; 
            width: 100%; 
            height: auto; 
        }

        /* ä¸‹æ–¹æŠ€èƒ½æŒ‰éˆ•å€åŸŸæ¨£å¼ */
        .skill-container { display: flex; justify-content: space-around; width: 100%; margin-top: 15px; }
        .skill-btn { width: 85px; height: 50px; background: #dfe6e9; border: 2px solid #b2bec3; border-radius: 12px; font-size: 13px; font-weight: bold; color: #2d3436; cursor: pointer; transition: all 0.2s; display: flex; justify-content: center; align-items: center; line-height: 1.2; text-align: center; }
        .skill-btn:active { transform: translateY(2px); }
        .skill-btn.active { background: #e74c3c; color: white; border-color: #c0392b; }
        
        /* æŠ€èƒ½ç¦ç”¨æ¨£å¼ */
        .skill-btn.used { background: #ced6e0; color: #a4b0be; border-color: #b2bec3; cursor: not-allowed; opacity: 0.6; filter: grayscale(1); pointer-events: none; }

        /* ğŸ’¡ è‡¨æ™‚æ¸¬è©¦é¢æ¿ (ç•«é¢å³å´) */
        #test-panel {
            position: fixed;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 12px;
            z-index: 9999;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        .test-btn {
            background: #ff4757;
            color: white;
            border: none;
            padding: 8px;
            border-radius: 6px;
            font-size: 11px;
            cursor: pointer;
            font-weight: bold;
            white-space: nowrap;
        }
        .test-btn:hover { background: #ff6b81; }
        .test-label { color: #f1f2f6; font-size: 12px; text-align: center; margin-bottom: 5px; border-bottom: 1px solid #777; padding-bottom: 5px; }

        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 8px; border-bottom: 1px solid #eee; font-size: 14px; }
        .result-score { font-size: 60px; font-weight: bold; color: var(--primary-color); margin: 5px 0; }
    </style>
</head>
<body>

    <!--<div id="test-panel">
        <div class="test-label">Debug æ¸¬è©¦å·¥å…·</div>
        <button class="test-btn" onclick="GameEngine.test_triggerDeadlock()">æ¨¡æ“¬æ­»å±€ (7/8/9 æ··æ­)</button>
        <button class="test-btn" onclick="GameEngine.test_clearBoard()">æ¨¡æ“¬ç›¤é¢æ¸…ç©º</button>
        <button class="test-btn" onclick="GameEngine.test_addTime()">å¼·åˆ¶åŠ æ™‚ +10s</button>
        <button class="test-btn" onclick="GameEngine.test_addScore()">å¼·åˆ¶åŠ åˆ† +500</button>
        <button class="test-btn" onclick="GameEngine.test_checkStatus()">æ‰‹å‹•åµæ¸¬ç‹€æ…‹</button>
    </div>-->

    <div id="screen-home" class="screen active">
        <h1>åœˆåéŠæˆ²</h1>
        <div class="name-input-group"><input type="text" id="home-player-name" placeholder="è«‹è¼¸å…¥åç¨±" maxlength="10"></div>
        <button class="btn btn-start" onclick="GameEngine.start()">é–‹å§‹éŠæˆ²</button>
        <button class="btn btn-rank" onclick="GameSystem.showLeaderboard()">æ’è¡Œæ¦œ</button>
    </div>

    <div id="screen-rank" class="screen">
        <h1>å…¨çƒæ’è¡Œæ¦œ</h1>
        <div style="max-height: 300px; overflow-y: auto; width: 100%;">
            <table id="rank-table">
                <thead><tr><th>æ’å</th><th>ç©å®¶</th><th>å¾—åˆ†</th></tr></thead>
                <tbody id="rank-body"></tbody>
            </table>
        </div>
        <button class="btn btn-back" onclick="GameEngine.backToHome()">å›ä¸»é¸å–®</button>
    </div>

    <div id="screen-game" class="screen">
        <div class="game-header">
            <div>Score: <span id="score">0</span></div>
            <div style="color: #e74c3c;">Time: <span id="timer">60</span>s</div>
            <div class="gear-btn" onclick="GameEngine.triggerQuitConfirm()">âš™ï¸</div>
        </div>
        <div id="game-canvas-container"><canvas id="gameCanvas" width="400" height="640"></canvas></div>
        <div class="skill-container">
            <button id="skill-btn-hint" class="skill-btn" onclick="GameEngine.useSkillHint()">ğŸ”<br>å°‹æ‰¾ä¸€çµ„</button>
            <button id="skill-btn-shuffle" class="skill-btn" onclick="GameEngine.useSkillShuffle(true)">ğŸŒ€<br>éš¨æ©Ÿæ‰“äº‚</button>
            <button id="skill-btn-delete" class="skill-btn" onclick="GameEngine.toggleDeleteMode()">ğŸ’£<br>åˆªé™¤ä¸€å€‹</button>
        </div>
    </div>

    <div id="screen-result" class="screen">
        <h1>éŠæˆ²çµæŸ</h1>
        <div class="result-score" id="final-result-score">0</div>
        <p id="result-player-display" style="margin-bottom: 20px;"></p>
        <button class="btn btn-upload" id="upload-btn" onclick="GameSystem.uploadScore()">ä¸Šå‚³æˆç¸¾</button>
        <button class="btn btn-back" onclick="GameEngine.backToHome()">å›ä¸»é¸å–®</button>
    </div>

<script>
/**
 * ==========================================
 * ç¬¬ä¸€éƒ¨åˆ†ï¼šç³»çµ±åŸºç¤è¨­æ–½ (SYSTEM SCRIPT)
 * ==========================================
 */
const GameSystem = (function() {
    const GAS_URL = "https://script.google.com/macros/s/AKfycbywi6spIec2aA3gD9gQbDu1w-4XJZ0wy3ZDdTWGlMX33FYZtuk7kmQjN7OKxJlJHkGr/exec";
    const SECRET_SALT = "8fK#z2N@v9W$pL5&mR8*qT1!uX6^yB3(kC0)jA7[mS4]nD2{gH9}fJ"; 

    async function getSignature(name, score, ts) {
        const msg = `${name}|${score}|${ts}|${SECRET_SALT}`;
        const encoder = new TextEncoder();
        const data = encoder.encode(msg);
        const hashBuffer = await crypto.subtle.digest('SHA-256', data);
        return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    return {
        showScreen: (id) => {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(id).classList.add('active');
        },
        showLeaderboard: async function() {
            this.showScreen('screen-rank');
            const tbody = document.getElementById('rank-body');
            tbody.innerHTML = "<tr><td colspan='3'>åŒæ­¥æ•¸æ“šä¸­...</td></tr>";
            try {
                const resp = await fetch(GAS_URL);
                const ranks = await resp.json();
                this.renderRankTable(ranks);
            } catch (e) {
                const cached = JSON.parse(localStorage.getItem('math_game_rank')) || [];
                this.renderRankTable(cached);
            }
        },
        renderRankTable: (ranks) => {
            const tbody = document.getElementById('rank-body');
            if (!ranks || ranks.length === 0) { tbody.innerHTML = "<tr><td colspan='3'>æš«ç„¡ç´€éŒ„</td></tr>"; return; }
            tbody.innerHTML = ranks.slice(0, 10).map((r, i) => {
                let rankClass = "", medal = "";
                if (i === 0) { rankClass = "rank-1"; medal = "ğŸ¥‡ "; }
                else if (i === 1) { rankClass = "rank-2"; medal = "ğŸ¥ˆ "; }
                else if (i === 2) { rankClass = "rank-3"; medal = "ğŸ¥‰ "; }
                return `<tr class="${rankClass}"><td>${medal}${i + 1}</td><td>${r.name || '-'}</td><td style="font-weight:bold">${r.score || 0}</td></tr>`;
            }).join('');
        },
        // ğŸ’¡ ä¸Šå‚³é‚è¼¯ï¼šåœ¨æ­¤è™•æª¢æŸ¥æ˜¯å¦ä½¿ç”¨äº†æ¸¬è©¦å·¥å…·
        uploadScore: async function() {
            const b = document.getElementById('upload-btn');
            const internal = GameEngine.getInternalState(); 
            
            if (internal.isTestUsed) {
                alert("æœ¬å±€ä½¿ç”¨äº†æ¸¬è©¦å·¥å…·ï¼Œç„¡æ³•ä¸Šå‚³æˆç¸¾ï¼");
                return;
            }

            b.disabled = true; b.innerText = "é©—è­‰ä¸­...";
            const ts = Date.now();
            const sign = await getSignature(internal.name, internal.score, ts);
            try {
                const resp = await fetch(GAS_URL, {
                    method: "POST",
                    body: JSON.stringify({ name: internal.name, score: internal.score, timestamp: ts, sign: sign, audit_skills: internal.skillsUsed })
                });
                const result = await resp.json();
                if (result.status === "error") throw new Error("é©—è­‰å¤±æ•—");
                localStorage.setItem('math_game_rank', JSON.stringify(result));
                alert("ğŸ‰ æˆç¸¾ä¸Šå‚³æˆåŠŸï¼");
                this.showLeaderboard();
            } catch (e) {
                alert("ä¸Šå‚³å¤±æ•—ï¼Œè«‹æª¢æŸ¥å¯†é‘°æˆ–ç¶²è·¯");
                b.disabled = false; b.innerText = "é‡è©¦ä¸Šå‚³";
            }
        },
        initNamePersistence: function() {
            const input = document.getElementById('home-player-name');
            const saved = localStorage.getItem('savedPlayerName') || "";
            input.value = saved;
            input.addEventListener('input', (e) => localStorage.setItem('savedPlayerName', e.target.value.trim()));
        }
    };
})();

/**
 * ==========================================
 * ç¬¬äºŒéƒ¨åˆ†ï¼šéŠæˆ²æ ¸å¿ƒå¼•æ“ (GAME SCRIPT)
 * ==========================================
 */
const GameEngine = (function() {
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const ROWS = 16, COLS = 10, GRID_SIZE = 40, MARGIN = 3;

    // éŠæˆ²é‹è¡Œä¸­çš„ç‹€æ…‹
    let state = {
        grid: [], score: 0, timeLeft: 60,
        gameActive: false, isConfirmingQuit: false,
        isDeleteMode: false,
        isTestUsed: false, // ğŸ’¡ æ–°å¢æ¸¬è©¦å·¥å…·ä½¿ç”¨æ¨™è¨˜
        name: "",
        skillsUsed: { hint: false, shuffle: false, delete: false }
    };

    let input = { isDragging: false, start: { x: 0, y: 0 }, current: { x: 0, y: 0 } };
    let particles = [], animationId = null, lastTime = 0, timerAcc = 0;

    const btns = { restart: { x: 70, y: 350, w: 120, h: 40 }, quit: { x: 210, y: 350, w: 120, h: 40 } };
    const pColors = ['#f1c40f', '#e67e22', '#e74c3c', '#3498db', '#2ecc71'];

    function clearHints() {
        state.grid.forEach(row => row.forEach(c => c.hinted = false));
    }

    function initGrid() {
        const total = ROWS * COLS, nums = [];
        for (let i = 0; i < total / 2; i++) { let n = Math.floor(Math.random() * 9) + 1; nums.push(n, 10 - n); }
        for (let i = nums.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [nums[i], nums[j]] = [nums[j], nums[i]]; }
        state.grid = Array.from({ length: ROWS }, (_, r) => Array.from({ length: COLS }, (_, c) => ({ val: nums[r * COLS + c], removed: false, active: false, hinted: false })));
    }

    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        state.grid.forEach((row, r) => row.forEach((cell, c) => {
            if (cell.removed) return;
            let x = c * GRID_SIZE + MARGIN, y = r * GRID_SIZE + MARGIN, s = GRID_SIZE - MARGIN * 2;
            ctx.beginPath(); ctx.roundRect(x, y, s, s, 6);
            if (state.isDeleteMode) { ctx.fillStyle = cell.active ? '#ff7675' : '#fab1a0'; }
            else if (cell.active) { ctx.fillStyle = '#ffbe76'; }
            else if (cell.hinted) { ctx.fillStyle = '#b8e994'; }
            else { ctx.fillStyle = '#ffffff'; }
            ctx.fill();
            ctx.strokeStyle = (cell.active || cell.hinted) ? '#e67e22' : '#f1f3f5'; ctx.lineWidth = 1.5; ctx.stroke();
            ctx.fillStyle = (cell.active || cell.hinted) ? '#fff' : '#2c3e50'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(cell.val, x + s/2, y + s/2);
        }));
        particles.forEach((p, i) => { p.x += p.vx; p.y += p.vy; p.life--; ctx.globalAlpha = p.life / 60; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill(); p.vy += 0.1; if (p.life <= 0) particles.splice(i, 1); });
        ctx.globalAlpha = 1;
        if (input.isDragging && !state.isConfirmingQuit && !state.isDeleteMode) {
            ctx.strokeStyle = '#3498db'; ctx.setLineDash([5, 3]); ctx.strokeRect(input.start.x, input.start.y, input.current.x - input.start.x, input.current.y - input.start.y); ctx.setLineDash([]); ctx.fillStyle = 'rgba(52, 152, 219, 0.1)'; ctx.fillRect(input.start.x, input.start.y, input.current.x - input.start.x, input.current.y - input.start.y);
        }
        if (state.isConfirmingQuit) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.roundRect(40, 250, 320, 170, 20); ctx.fill(); ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 22px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'top'; ctx.fillText('ç¢ºå®šè¦çµæŸéŠæˆ²å—ï¼Ÿ', canvas.width/2, 285);
            drawCanvasBtn(btns.restart, '#27ae60', 'é‡æ–°é–‹å§‹'); drawCanvasBtn(btns.quit, '#95a5a6', 'çµæŸéŠæˆ²');
        }
    }

    function drawCanvasBtn(b, c, t) { ctx.fillStyle = c; ctx.beginPath(); ctx.roundRect(b.x, b.y, b.w, b.h, 24); ctx.fill(); ctx.fillStyle = '#fff'; ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(t, b.x + b.w/2, b.y + b.h/2); }

    // ğŸ’¡ æ™ºæ…§æƒæï¼šå°‹æ‰¾å ´ä¸Šæ˜¯å¦é‚„æœ‰ç§»å‹•çµ„åˆ
    function findOneMove() {
        for (let r1 = 0; r1 < ROWS; r1++) {
            for (let c1 = 0; c1 < COLS; c1++) {
                if (state.grid[r1][c1].removed) continue;
                for (let r2 = r1; r2 < ROWS; r2++) {
                    for (let c2 = c1; c2 < COLS; c2++) {
                        let sum = 0, cells = [];
                        for (let r = r1; r <= r2; r++) {
                            for (let c = c1; c <= c2; c++) {
                                if (!state.grid[r][c].removed) { sum += state.grid[r][c].val; cells.push(state.grid[r][c]); }
                            }
                        }
                        if (sum === 10 && cells.length > 0) return cells;
                    }
                }
            }
        }
        return null;
    }

    // ğŸ’¡ æ ¸å¿ƒæª¢æŸ¥ï¼šè™•ç†æ­»å±€è‡ªå‹•æ‰“äº‚èˆ‡æ¸…ç©ºè‡ªå‹•åˆ·æ–°
    function checkBoardStatus() {
        const remaining = state.grid.flat().filter(c => !c.removed);
        
        // 1. ç›¤é¢æ¸…ç©ºï¼šè‡ªå‹•åˆ·æ–°æ–°é¢æ¿
        if (remaining.length === 0) {
            alert("æ­å–œæ¸…ç©ºç›¤é¢ï¼é‡æ–°ç™¼æ”¾æ•¸å­—ç¹¼çºŒç´¯åˆ†ï¼");
            initGrid();
            return;
        }

        // 2. æ­»å±€åˆ¤å®šï¼šè‹¥æ²’ç”¨éæ‰“äº‚å‰‡è‡ªå‹•ä½¿ç”¨ï¼Œå¦å‰‡çµæŸéŠæˆ²
        if (!findOneMove()) {
            if (!state.skillsUsed.shuffle) {
                alert("å ´ä¸Šç„¡è§£ï¼è‡ªå‹•ç‚ºæ‚¨ä½¿ç”¨ã€Œéš¨æ©Ÿæ‰“äº‚ã€æŠ€èƒ½é€²è¡Œé‡ç”Ÿ...");
                GameEngine.useSkillShuffle(true); // è‡ªå‹•è§¸ç™¼ä¸¦æ¨™è¨˜æ¶ˆè€—
            } else {
                alert("å·²ç„¡ä»»ä½•çµ„åˆä¸”æ‰“äº‚æŠ€èƒ½å·²è€—ç›¡ï¼ŒéŠæˆ²çµæŸï¼");
                GameEngine.end();
            }
        }
    }

    return {
        // ğŸ’¡ ä¿®å¾© getPos å°å¤–é–‹æ”¾å•é¡Œ
        getPos: (e) => {
            const rect = canvas.getBoundingClientRect();
            return { x: (e.clientX - rect.left) * (canvas.width / rect.width), y: (e.clientY - rect.top) * (canvas.height / rect.height) };
        },

        getInternalState: () => ({ name: state.name, score: state.score, skillsUsed: state.skillsUsed, isTestUsed: state.isTestUsed }),
        
        start: function() {
            const nameInput = document.getElementById('home-player-name');
            const inputName = nameInput.value.trim();
            if (!inputName) { alert("è«‹è¼¸å…¥åç¨±æ‰èƒ½é–‹å§‹ï¼"); nameInput.focus(); return; }
            if (inputName.length > 10) { alert("åç¨±æœ€å¤š 10 å€‹å­—ï¼"); return; }
            this.stop(); state.name = inputName; state.isDeleteMode = false; state.isTestUsed = false;
            state.skillsUsed = { hint: false, shuffle: false, delete: false };
            document.querySelectorAll('.skill-btn').forEach(b => b.classList.remove('used', 'active'));
            localStorage.setItem('savedPlayerName', state.name); GameSystem.showScreen('screen-game');
            state.score = 0; state.timeLeft = 60; state.gameActive = true; state.isConfirmingQuit = false; particles = [];
            document.getElementById('score').innerText = 0; document.getElementById('timer').innerText = 60;
            initGrid(); lastTime = performance.now(); timerAcc = 0; this.loop(lastTime);
        },
        
        stop: function() { state.gameActive = false; if(animationId) { cancelAnimationFrame(animationId); animationId = null; } },
        
        loop: function(t) {
            if (!state.gameActive) return;
            const dt = t - lastTime; lastTime = t; timerAcc += dt;
            if (timerAcc >= 1000) { state.timeLeft--; document.getElementById('timer').innerText = state.timeLeft; timerAcc -= 1000; if (state.timeLeft <= 0) this.end(); }
            if (input.isDragging && !state.isDeleteMode) this.updateStates();
            render(); animationId = requestAnimationFrame((ts) => this.loop(ts));
        },

        useSkillHint: function() {
            if (!state.gameActive || state.isConfirmingQuit || state.skillsUsed.hint) return;
            if (state.isDeleteMode) this.toggleDeleteMode(); 
            const cells = findOneMove();
            if (cells) {
                state.skillsUsed.hint = true; document.getElementById('skill-btn-hint').classList.add('used');
                cells.forEach(cell => cell.hinted = true);
                setTimeout(() => { clearHints(); }, 10000); 
            } else { alert("ç›®å‰ç„¡çµ„åˆï¼"); }
        },

        useSkillShuffle: function(markUsed = true) {
            if (!state.gameActive || state.isConfirmingQuit) return;
            if (markUsed && state.skillsUsed.shuffle) return;
            
            clearHints(); 
            if (markUsed) { 
                state.skillsUsed.shuffle = true; 
                document.getElementById('skill-btn-shuffle').classList.add('used');
            }
            
            let activeCells = state.grid.flat().filter(cell => !cell.removed);
            let values = activeCells.map(c => c.val);
            for (let i = values.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [values[i], values[j]] = [values[j], values[i]]; }
            activeCells.forEach((cell, i) => { cell.val = values[i]; });
            
            // æ´—ç‰Œå¾Œä¾ç„¶ç„¡è§£å‰‡æŒçºŒæ´—åˆ°æœ‰è§£ç‚ºæ­¢ (ä¸é¡å¤–æ‰£æ¬¡æ•¸)
            if (activeCells.length > 0 && !findOneMove()) {
                this.useSkillShuffle(false);
            }
        },

        toggleDeleteMode: function() {
            if (!state.gameActive || state.isConfirmingQuit || state.skillsUsed.delete) return;
            clearHints(); 
            state.isDeleteMode = !state.isDeleteMode; document.getElementById('skill-btn-delete').classList.toggle('active', state.isDeleteMode);
        },

        handleDown: function(pos) {
            if (!state.gameActive) return;
            const isInside = (p, b) => p.x >= b.x && p.x <= b.x + b.w && p.y >= b.y && p.y <= b.y + b.h;
            if (state.isConfirmingQuit) { if (isInside(pos, btns.restart)) this.start(); else if (isInside(pos, btns.quit)) this.backToHome(); else state.isConfirmingQuit = false; return; }
            
            if (state.isDeleteMode) {
                const c = Math.floor(pos.x / GRID_SIZE), r = Math.floor(pos.y / GRID_SIZE);
                if (r >= 0 && r < ROWS && c >= 0 && c < COLS && !state.grid[r][c].removed) {
                    state.grid[r][c].removed = true; state.skillsUsed.delete = true; state.isDeleteMode = false;
                    document.getElementById('skill-btn-delete').classList.remove('active');
                    document.getElementById('skill-btn-delete').classList.add('used');
                    this.spawnBoom([{r, c}]); checkBoardStatus();
                }
                return;
            }
            clearHints(); 
            input.isDragging = true; input.start = pos; input.current = { ...pos };
        },

        handleMove: function(pos) { if (input.isDragging && !state.isDeleteMode) input.current = pos; },

        handleUp: function() {
            if (!input.isDragging || state.isDeleteMode) return; input.isDragging = false;
            let sel = state.grid.flat().filter(c => !c.removed && c.active);
            if (sel.reduce((s, c) => s + c.val, 0) === 10 && sel.length > 0) { 
                state.timeLeft += 5; state.score += sel.length * 100; document.getElementById('score').innerText = state.score; document.getElementById('timer').innerText = state.timeLeft; 
                this.spawnBoom(sel); sel.forEach(c => c.removed = true); 
                checkBoardStatus(); // ğŸ’¡ æ¯æ¬¡æ¶ˆé™¤å¾Œæª¢æŸ¥ç›¤é¢ç‹€æ…‹
            }
            state.grid.flat().forEach(c => c.active = false);
        },

        updateStates: () => {
            let x1 = Math.min(input.start.x, input.current.x), x2 = Math.max(input.start.x, input.current.x), y1 = Math.min(input.start.y, input.current.y), y2 = Math.max(input.start.y, input.current.y);
            state.grid.forEach((row, r) => row.forEach((cell, c) => { let tx1 = c * GRID_SIZE, tx2 = (c+1) * GRID_SIZE, ty1 = r * GRID_SIZE, ty2 = (r+1) * GRID_SIZE; cell.active = !(tx2 < x1 || tx1 > x2 || ty2 < y1 || ty1 > y2); }));
        },

        spawnBoom: (targets) => {
            if (!targets || targets.length === 0) return;
            let cx, cy;
            if (targets[0].r !== undefined) {
                cx = (targets[0].c + 0.5) * GRID_SIZE; cy = (targets[0].r + 0.5) * GRID_SIZE;
            } else {
                let minC=10, maxC=0, minR=16, maxR=0;
                targets.forEach(c => {
                    const idx = state.grid.flat().indexOf(c);
                    const col = idx % COLS, row = Math.floor(idx / COLS);
                    minC = Math.min(minC, col); maxC = Math.max(maxC, col); minR = Math.min(minR, row); maxR = Math.max(maxR, row);
                });
                cx = (minC + maxC + 1) * GRID_SIZE / 2; cy = (minR + maxR + 1) * GRID_SIZE / 2;
            }
            for (let i = 0; i < 20; i++) { const ang = Math.random() * Math.PI * 2, spd = Math.random() * 4 + 2; particles.push({ x: cx, y: cy, vx: Math.cos(ang)*spd, vy: Math.sin(ang)*spd, life: 30+Math.random()*20, size: 2+Math.random()*3, color: pColors[Math.floor(Math.random()*pColors.length)] }); }
        },

        triggerQuitConfirm: () => { if(state.gameActive) state.isConfirmingQuit = !state.isConfirmingQuit; },
        backToHome: function() { this.stop(); GameSystem.showScreen('screen-home'); },
        end: function() { 
            this.stop(); 
            document.getElementById('final-result-score').innerText = state.score; 
            document.getElementById('result-player-display').innerText = `Player: ${state.name}`; 
            
            // ğŸ’¡ è‹¥ä½¿ç”¨äº†æ¸¬è©¦å·¥å…·ï¼Œç¦ç”¨ä¸Šå‚³æŒ‰éˆ•
            const uploadBtn = document.getElementById('upload-btn');
            if (state.isTestUsed) {
                uploadBtn.disabled = true;
                uploadBtn.innerText = "æ¸¬è©¦æ¨¡å¼ç¦æ­¢ä¸Šå‚³";
            } else {
                uploadBtn.disabled = false;
                uploadBtn.innerText = "ä¸Šå‚³æˆç¸¾";
            }
            GameSystem.showScreen('screen-result'); 
        },

        // --- ğŸ’¡ è‡¨æ™‚æ¸¬è©¦å·¥å…· (åŸ·è¡Œå³æ¨™è¨˜ isTestUsed) ---
        test_triggerDeadlock: function() {
            state.isTestUsed = true;
            state.grid.flat().forEach(c => c.removed = true);
            const testNums = [7, 8, 9];
            for(let r=0; r<5; r++) {
                for(let c=0; c<COLS; c++) {
                    const val = testNums[Math.floor(Math.random() * testNums.length)];
                    state.grid[r][c] = { val, removed: false, active: false, hinted: false };
                }
            }
            alert("æ¨¡æ“¬æ­»å±€æˆåŠŸï¼å°‡è§¸ç™¼è‡ªå‹•æ¶ˆè€—æŠ€èƒ½æ‰“äº‚é‚è¼¯ã€‚"); checkBoardStatus();
        },
        test_clearBoard: function() {
            state.isTestUsed = true;
            state.grid.flat().forEach(c => c.removed = true);
            alert("æ¨¡æ“¬ç›¤é¢æ¸…ç©ºï¼å°‡è§¸ç™¼è‡ªå‹•åˆ·æ–°é‚è¼¯ã€‚"); checkBoardStatus();
        },
        test_addTime: function() { state.isTestUsed = true; state.timeLeft += 10; document.getElementById('timer').innerText = state.timeLeft; },
        test_addScore: function() { state.isTestUsed = true; state.score += 500; document.getElementById('score').innerText = state.score; },
        test_checkStatus: function() { checkBoardStatus(); }
    };
})();

/**
 * ==========================================
 * ç¬¬ä¸‰éƒ¨åˆ†ï¼šåˆå§‹åŒ–èˆ‡äº‹ä»¶ç›£è½
 * ==========================================
 */
window.addEventListener('load', () => {
    GameSystem.initNamePersistence();
    const canvas = document.getElementById('gameCanvas');

    canvas.addEventListener('pointerdown', (e) => {
        canvas.setPointerCapture(e.pointerId);
        GameEngine.handleDown(GameEngine.getPos(e));
    });

    window.addEventListener('pointermove', (e) => {
        GameEngine.handleMove(GameEngine.getPos(e));
    });

    window.addEventListener('pointerup', (e) => {
        canvas.releasePointerCapture(e.pointerId);
        GameEngine.handleUp();
    });

    document.addEventListener('touchstart', (e) => { if (e.touches.length > 1) e.preventDefault(); }, { passive: false });
    document.addEventListener('gesturestart', (e) => e.preventDefault());
});
</script>
</body>
</html>
