<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>åœˆåéŠæˆ²</title>
    <style>
        /* --- åŸºç¤æ¨£å¼èˆ‡æ‰‹æ©Ÿå„ªåŒ– --- */
        :root { 
            --primary-color: #4a90e2; 
            --secondary-color: #27ae60; 
            --bg-color: #f0f4f8; 
            --text-color: #2c3e50; 
        }
        
        /* é–å®šæ‰‹æ©Ÿæ‰‹å‹¢ï¼šç¦æ­¢é¸å–èˆ‡ç³»çµ±é¸å–® */
        * { 
            -webkit-tap-highlight-color: transparent; 
            user-select: none; 
            -webkit-user-select: none; 
            touch-action: manipulation; 
        }

        body { 
            font-family: 'PingFang TC', 'Microsoft JhengHei', sans-serif; 
            background-color: var(--bg-color); 
            margin: 0; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            color: var(--text-color); 
            overscroll-behavior-y: contain; /* é˜²æ­¢æ‰‹æ©Ÿä¸‹æ‹‰æ›´æ–° */
            overflow: hidden; 
        }

        /* è¦–çª—å®¹å™¨æ¨£å¼ */
        .screen { 
            display: none; 
            flex-direction: column; 
            align-items: center; 
            background: white; 
            padding: 25px; 
            border-radius: 24px; 
            box-shadow: 0 10px 40px rgba(0,0,0,0.1); 
            width: 92%; 
            max-width: 450px; 
            text-align: center; 
            box-sizing: border-box; 
        }

        .screen.active { display: flex; }

        h1 { font-size: 32px; margin: 0 0 15px 0; color: var(--primary-color); }

        /* è¼¸å…¥æ¡†èˆ‡æŒ‰éˆ•å°ºå¯¸å„ªåŒ– */
        input { 
            padding: 10px; 
            font-size: 16px; 
            border: 2px solid #e1e8ed; 
            border-radius: 12px; 
            width: 180px; 
            text-align: center; 
            outline: none; 
            user-select: auto; 
            -webkit-user-select: auto; 
        }

        .btn { 
            padding: 12px 0; 
            font-size: 16px; 
            margin: 6px 0; 
            border: none; 
            border-radius: 50px; 
            cursor: pointer; 
            width: 180px; 
            font-weight: bold; 
            transition: transform 0.1s; 
        }
        .btn:active { transform: scale(0.95); }
        .btn-start { background: var(--secondary-color); color: white; }
        .btn-rank { background: var(--primary-color); color: white; }
        .btn-upload { background: #f39c12; color: white; }
        .btn-back { background: #95a5a6; color: white; }

        .game-header { display: flex; justify-content: space-between; width: 100%; margin-bottom: 10px; font-size: 20px; font-weight: bold; }
        #game-canvas-container { background: #eee; padding: 4px; border-radius: 12px; }
        
        /* ç•«å¸ƒï¼šç¦æ­¢é è¨­è§¸æ§è¡Œç‚ºä»¥åˆ©æ¡†é¸ */
        canvas { background: #fff; border-radius: 8px; display: block; touch-action: none; width: 100%; height: auto; }
        
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 8px; border-bottom: 1px solid #eee; font-size: 14px; }
        .result-score { font-size: 60px; font-weight: bold; color: var(--primary-color); margin: 5px 0; }
    </style>
</head>
<body>

    <div id="screen-home" class="screen active">
        <h1>åœˆåéŠæˆ²</h1>
        <div class="name-input-group">
            <input type="text" id="home-player-name" placeholder="è«‹è¼¸å…¥åç¨±" maxlength="10">
        </div>
        <button class="btn btn-start" onclick="GameEngine.start()">é–‹å§‹éŠæˆ²</button>
        <button class="btn btn-rank" onclick="GameSystem.showLeaderboard()">æ’è¡Œæ¦œ</button>
    </div>

    <div id="screen-rank" class="screen">
        <h1>å…¨çƒæ’è¡Œæ¦œ</h1>
        <div style="max-height: 300px; overflow-y: auto; width: 100%;">
            <table id="rank-table"><thead><tr><th>æ’å</th><th>ç©å®¶</th><th>å¾—åˆ†</th></tr></thead><tbody id="rank-body"></tbody></table>
        </div>
        <button class="btn btn-back" onclick="GameEngine.backToHome()">å›ä¸»é¸å–®</button>
    </div>

    <div id="screen-game" class="screen">
        <div class="game-header"><div>Score: <span id="score">0</span></div><div style="color: #e74c3c;">Time: <span id="timer">60</span>s</div></div>
        <div id="game-canvas-container"><canvas id="gameCanvas" width="400" height="640"></canvas></div>
        <button class="btn btn-back" onclick="GameEngine.triggerQuitConfirm()" style="width: 140px; font-size: 14px; margin-top: 15px;">çµæŸéŠæˆ²</button>
    </div>

    <div id="screen-result" class="screen">
        <h1>éŠæˆ²çµæŸ</h1>
        <div class="result-score" id="final-result-score">0</div>
        <p id="result-player-display" style="margin-bottom: 20px;"></p>
        <button class="btn btn-upload" id="upload-btn" onclick="GameSystem.uploadScore()">ä¸Šå‚³æˆç¸¾</button>
        <button class="btn btn-back" onclick="GameEngine.backToHome()">å›ä¸»é¸å–®</button>
    </div>

<script>
/**
 * ==========================================
 * ç¬¬ä¸€éƒ¨åˆ†ï¼šç³»çµ±åŸºç¤è¨­æ–½ (SYSTEM SCRIPT)
 * è² è²¬ï¼šå®‰å…¨æ ¡é©—ã€GAS é€šè¨Šã€ç©å®¶è³‡æ–™æŒä¹…åŒ–
 * ==========================================
 */
const GameSystem = (function() {
    const GAS_URL = "https://script.google.com/macros/s/AKfycbywi6spIec2aA3gD9gQbDu1w-4XJZ0wy3ZDdTWGlMX33FYZtuk7kmQjN7OKxJlJHkGr/exec";
    const SECRET_SALT = "8fK#z2N@v9W$pL5&mR8*qT1!uX6^yB3(kC0)jA7[mS4]nD2{gH9}fJ";

    async function getSignature(name, score, ts) {
        const msg = `${name}|${score}|${ts}|${SECRET_SALT}`;
        const encoder = new TextEncoder();
        const data = encoder.encode(msg);
        const hashBuffer = await crypto.subtle.digest('SHA-256', data);
        return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    return {
        showScreen: (id) => {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(id).classList.add('active');
        },
        showLeaderboard: async function() {
            this.showScreen('screen-rank');
            const tbody = document.getElementById('rank-body');
            tbody.innerHTML = "<tr><td colspan='3'>åŒæ­¥æ•¸æ“šä¸­...</td></tr>";
            try {
                const resp = await fetch(GAS_URL);
                const ranks = await resp.json();
                this.renderRankTable(ranks);
            } catch (e) {
                const cached = JSON.parse(localStorage.getItem('math_game_rank')) || [];
                this.renderRankTable(cached);
            }
        },
        renderRankTable: (ranks) => {
            const tbody = document.getElementById('rank-body');
            if (!ranks || ranks.length === 0) { tbody.innerHTML = "<tr><td colspan='3'>æš«ç„¡ç´€éŒ„</td></tr>"; return; }
            tbody.innerHTML = ranks.slice(0, 10).map((r, i) => {
                let rankClass = "", medal = "";
                if (i === 0) { rankClass = "rank-1"; medal = "ğŸ¥‡ "; }
                else if (i === 1) { rankClass = "rank-2"; medal = "ğŸ¥ˆ "; }
                else if (i === 2) { rankClass = "rank-3"; medal = "ğŸ¥‰ "; }
                return `<tr class="${rankClass}"><td>${medal}${i + 1}</td><td>${r.name || '-'}</td><td style="font-weight:bold">${r.score || 0}</td></tr>`;
            }).join('');
        },
        uploadScore: async function() {
            const b = document.getElementById('upload-btn');
            const state = GameEngine.getInternalState();
            b.disabled = true; b.innerText = "é©—è­‰ä¸­...";
            const ts = Date.now();
            const sign = await getSignature(state.name, state.score, ts);
            try {
                const resp = await fetch(GAS_URL, {
                    method: "POST",
                    body: JSON.stringify({ name: state.name, score: state.score, timestamp: ts, sign: sign })
                });
                const result = await resp.json();
                if (result.status === "error") throw new Error("ç°½ç« é©—è­‰å¤±æ•—");
                localStorage.setItem('math_game_rank', JSON.stringify(result));
                alert("ğŸ‰ æˆç¸¾å·²å®‰å…¨ä¸Šå‚³ï¼");
                this.showLeaderboard();
            } catch (e) {
                alert("ä¸Šå‚³å¤±æ•—ï¼šå¯†é‘°ä¸ç¬¦æˆ–ç¶²è·¯ç•°å¸¸");
                b.disabled = false; b.innerText = "é‡è©¦ä¸Šå‚³";
            }
        },
        initNamePersistence: function() {
            const input = document.getElementById('home-player-name');
            const saved = localStorage.getItem('savedPlayerName') || "";
            input.value = saved;
            input.addEventListener('input', (e) => localStorage.setItem('savedPlayerName', e.target.value.trim()));
        }
    };
})();

/**
 * ==========================================
 * ç¬¬äºŒéƒ¨åˆ†ï¼šéŠæˆ²æ ¸å¿ƒå¼•æ“ (GAME SCRIPT)
 * è² è²¬ï¼šæ¸²æŸ“ã€10x16 ç¶²æ ¼ç©æ³•ã€ä¸»è¿´åœˆ
 * ==========================================
 */
const GameEngine = (function() {
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const ROWS = 16, COLS = 10, GRID_SIZE = 40, MARGIN = 3;

    let state = {
        grid: [], score: 0, timeLeft: 60,
        gameActive: false, isConfirmingQuit: false,
        name: ""
    };

    let input = { isDragging: false, start: { x: 0, y: 0 }, current: { x: 0, y: 0 } };
    let particles = [], animationId = null, lastTime = 0, timerAcc = 0;

    const btns = { restart: { x: 70, y: 350, w: 120, h: 40 }, quit: { x: 210, y: 350, w: 120, h: 40 } };

    function initGrid() {
        const total = ROWS * COLS, nums = [];
        for (let i = 0; i < total / 2; i++) { 
            let n = Math.floor(Math.random() * 9) + 1; 
            nums.push(n, 10 - n);
        }
        for (let i = nums.length - 1; i > 0; i--) { 
            const j = Math.floor(Math.random() * (i + 1)); 
            [nums[i], nums[j]] = [nums[j], nums[i]]; 
        }
        state.grid = Array.from({ length: ROWS }, (_, r) => 
            Array.from({ length: COLS }, (_, c) => ({ val: nums[r * COLS + c], removed: false, active: false }))
        );
    }

    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        state.grid.forEach((row, r) => row.forEach((cell, c) => {
            if (cell.removed) return;
            let x = c * GRID_SIZE + MARGIN, y = r * GRID_SIZE + MARGIN, s = GRID_SIZE - MARGIN * 2;
            ctx.beginPath(); ctx.roundRect(x, y, s, s, 6);
            ctx.fillStyle = cell.active ? '#ffbe76' : '#ffffff'; ctx.fill();
            ctx.strokeStyle = cell.active ? '#e67e22' : '#f1f3f5'; ctx.lineWidth = 1.5; ctx.stroke();
            ctx.fillStyle = cell.active ? '#fff' : '#2c3e50'; ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(cell.val, x + s/2, y + s/2);
        }));
        particles.forEach((p, i) => {
            p.x += p.vx; p.y += p.vy; p.life--; ctx.globalAlpha = p.life / 60;
            ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
            p.vy += 0.1; if (p.life <= 0) particles.splice(i, 1);
        });
        ctx.globalAlpha = 1;
        if (input.isDragging && !state.isConfirmingQuit) {
            ctx.strokeStyle = '#3498db'; ctx.setLineDash([5, 3]);
            ctx.strokeRect(input.start.x, input.start.y, input.current.x - input.start.x, input.current.y - input.start.y);
            ctx.setLineDash([]); ctx.fillStyle = 'rgba(52, 152, 219, 0.1)';
            ctx.fillRect(input.start.x, input.start.y, input.current.x - input.start.x, input.current.y - input.start.y);
        }
        if (state.isConfirmingQuit) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.roundRect(40, 250, 320, 170, 20); ctx.fill();
            ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 22px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
            ctx.fillText('ç¢ºå®šè¦çµæŸéŠæˆ²å—ï¼Ÿ', canvas.width/2, 285);
            drawCanvasBtn(btns.restart, '#27ae60', 'é‡æ–°é–‹å§‹');
            drawCanvasBtn(btns.quit, '#95a5a6', 'çµæŸéŠæˆ²');
        }
    }

    function drawCanvasBtn(b, c, t) {
        ctx.fillStyle = c; ctx.beginPath(); ctx.roundRect(b.x, b.y, b.w, b.h, 24); ctx.fill();
        ctx.fillStyle = '#fff'; ctx.font = 'bold 16px Arial'; 
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(t, b.x + b.w/2, b.y + b.h/2);
    }

    function getPointerPos(e) {
        const rect = canvas.getBoundingClientRect();
        return { 
            x: (e.clientX - rect.left) * (canvas.width / rect.width), 
            y: (e.clientY - rect.top) * (canvas.height / rect.height) 
        };
    }

    return {
        getInternalState: () => ({ name: state.name, score: state.score }),

        // ğŸ’¡ é»æ“Šé–‹å§‹éŠæˆ²ï¼šåŠ å…¥é©—è­‰é‚è¼¯
        start: function() {
            const nameInput = document.getElementById('home-player-name');
            const inputName = nameInput.value.trim();

            // 1. é©—è­‰æ˜¯å¦è¼¸å…¥åç¨±
            if (!inputName) {
                alert("è«‹è¼¸å…¥ç©å®¶åç¨±æ‰èƒ½é–‹å§‹éŠæˆ²ï¼");
                nameInput.focus();
                return;
            }

            // 2. é©—è­‰åç¨±é•·åº¦ (é›™é‡ä¿éšª)
            if (inputName.length > 10) {
                alert("ç©å®¶åç¨±ä¸èƒ½è¶…é 10 å€‹å­—å–”ï¼");
                return;
            }

            this.stop();
            state.name = inputName;
            localStorage.setItem('savedPlayerName', state.name); // å„²å­˜è‡³æœ¬åœ°
            
            GameSystem.showScreen('screen-game');
            state.score = 0; state.timeLeft = 60; state.gameActive = true;
            state.isConfirmingQuit = false; particles = [];
            document.getElementById('score').innerText = 0;
            document.getElementById('timer').innerText = 60;
            initGrid();
            lastTime = performance.now(); timerAcc = 0;
            this.loop(lastTime);
        },

        stop: function() {
            state.gameActive = false;
            if(animationId) { cancelAnimationFrame(animationId); animationId = null; }
        },

        loop: function(t) {
            if (!state.gameActive) return;
            const dt = t - lastTime; lastTime = t; timerAcc += dt;
            if (timerAcc >= 1000) {
                state.timeLeft--; document.getElementById('timer').innerText = state.timeLeft;
                timerAcc -= 1000; if (state.timeLeft <= 0) this.end();
            }
            if (input.isDragging) this.updateSelection();
            render();
            animationId = requestAnimationFrame((ts) => this.loop(ts));
        },

        handleDown: function(e) {
            if (!state.gameActive) return;
            const pos = getPointerPos(e);
            if (state.isConfirmingQuit) {
                const isInside = (p, b) => p.x >= b.x && p.x <= b.x + b.w && p.y >= b.y && p.y <= b.y + b.h;
                if (isInside(pos, btns.restart)) this.start();
                else if (isInside(pos, btns.quit)) this.backToHome();
                else state.isConfirmingQuit = false;
                return;
            }
            input.isDragging = true; input.start = pos; input.current = { ...pos };
        },

        handleMove: function(e) { if (input.isDragging) input.current = getPointerPos(e); },

        handleUp: function() {
            if (!input.isDragging) return; input.isDragging = false;
            let sel = state.grid.flat().filter(c => !c.removed && c.active);
            if (sel.reduce((s, c) => s + c.val, 0) === 10 && sel.length > 0) {
                state.timeLeft += 5; // çå‹µæ™‚é–“
                state.score += sel.length * 100;
                document.getElementById('score').innerText = state.score;
                document.getElementById('timer').innerText = state.timeLeft;
                this.spawnBoom(sel);
                sel.forEach(c => c.removed = true);
            }
            state.grid.flat().forEach(c => c.active = false);
            if (state.grid.flat().every(c => c.removed)) this.end();
        },

        updateSelection: () => {
            let x1 = Math.min(input.start.x, input.current.x), x2 = Math.max(input.start.x, input.current.x);
            let y1 = Math.min(input.start.y, input.current.y), y2 = Math.max(input.start.y, input.current.y);
            state.grid.forEach((row, r) => row.forEach((cell, c) => {
                let tx1 = c * GRID_SIZE, tx2 = (c+1) * GRID_SIZE, ty1 = r * GRID_SIZE, ty2 = (r+1) * GRID_SIZE;
                cell.active = !(tx2 < x1 || tx1 > x2 || ty2 < y1 || ty1 > y2);
            }));
        },

        spawnBoom: (sel) => {
            let minC=10, maxC=0, minR=16, maxR=0;
            state.grid.forEach((row, r) => row.forEach((cell, col) => {
                if(cell.active && !cell.removed) {
                    minC=Math.min(minC, col); maxC=Math.max(maxC, col);
                    minR=Math.min(minR, r); maxR=Math.max(maxR, r);
                }
            }));
            const cx = (minC + maxC + 1) * GRID_SIZE / 2, cy = (minR + maxR + 1) * GRID_SIZE / 2;
            for (let i = 0; i < 20; i++) {
                const ang = Math.random() * Math.PI * 2, spd = Math.random() * 4 + 2;
                particles.push({ x: cx, y: cy, vx: Math.cos(ang)*spd, vy: Math.sin(ang)*spd, life: 30+Math.random()*20, size: 2+Math.random()*3, color: ['#f1c40f','#e74c3c','#3498db'][Math.floor(Math.random()*3)] });
            }
        },

        triggerQuitConfirm: () => { if(state.gameActive) state.isConfirmingQuit = !state.isConfirmingQuit; },
        backToHome: function() { this.stop(); GameSystem.showScreen('screen-home'); },
        end: function() {
            this.stop();
            document.getElementById('final-result-score').innerText = state.score;
            document.getElementById('result-player-display').innerText = `Player: ${state.name}`;
            GameSystem.showScreen('screen-result');
        }
    };
})();

/**
 * ==========================================
 * ç¬¬ä¸‰éƒ¨åˆ†ï¼šäº‹ä»¶ç¶å®šèˆ‡åˆå§‹åŒ–
 * ==========================================
 */
window.addEventListener('load', () => {
    GameSystem.initNamePersistence();
    const canvas = document.getElementById('gameCanvas');

    canvas.addEventListener('pointerdown', (e) => {
        canvas.setPointerCapture(e.pointerId);
        GameEngine.handleDown(e);
    });

    window.addEventListener('pointermove', (e) => {
        GameEngine.handleMove(e);
    });

    window.addEventListener('pointerup', (e) => {
        canvas.releasePointerCapture(e.pointerId);
        GameEngine.handleUp();
    });

    document.addEventListener('touchstart', (e) => { if (e.touches.length > 1) e.preventDefault(); }, { passive: false });
    document.addEventListener('gesturestart', (e) => e.preventDefault());
});
</script>
</body>
</html>
