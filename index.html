<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>åœˆåéŠæˆ² - Bug Fix ç‰ˆ</title>
    <style>
        :root {
            --primary-color: #4a90e2;
            --secondary-color: #27ae60;
            --bg-color: #f0f4f8;
            --tile-active: #ffbe76;
            --text-color: #2c3e50;
        }

        body {
            font-family: 'PingFang TC', 'Microsoft JhengHei', sans-serif;
            background-color: var(--bg-color);
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: var(--text-color);
            overscroll-behavior-y: contain;
        }

        .screen {
            display: none;
            flex-direction: column;
            align-items: center;
            background: white;
            padding: 30px;
            border-radius: 24px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            width: 95%;
            max-width: 500px;
            text-align: center;
            box-sizing: border-box;
            margin: 10px;
        }

        .screen.active { display: flex; }

        h1 { font-size: 32px; margin: 0 0 20px 0; color: var(--primary-color); }

        .name-input-group { margin-bottom: 20px; }
        input {
            padding: 10px;
            font-size: 16px;
            border: 2px solid #e1e8ed;
            border-radius: 12px;
            width: 180px;
            text-align: center;
            outline: none;
        }

        .btn {
            padding: 10px 0;
            font-size: 16px;
            margin: 6px 0;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            width: 180px;
            font-weight: bold;
            transition: transform 0.2s;
        }
        .btn-start { background: var(--secondary-color); color: white; }
        .btn-rank { background: var(--primary-color); color: white; }
        .btn-upload { background: #f39c12; color: white; }
        .btn-back { background: #95a5a6; color: white; }

        .game-header {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 10px;
            font-size: 20px;
            font-weight: bold;
        }
        #game-canvas-container { background: #eee; padding: 5px; border-radius: 12px; }
        
        canvas { 
            background: #fff; 
            border-radius: 8px; 
            display: block; 
            touch-action: none; 
            max-width: 100%;
            height: auto;
        }

        table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        th, td { padding: 8px; border-bottom: 1px solid #eee; font-size: 14px; }
        .result-score { font-size: 56px; font-weight: bold; color: var(--primary-color); margin: 10px 0; }
        .rank-1 { background-color: rgba(255, 215, 0, 0.1); color: #b8860b; }
        .rank-2 { background-color: rgba(192, 192, 192, 0.1); color: #708090; }
        .rank-3 { background-color: rgba(205, 127, 50, 0.1); color: #8b4513; }
    </style>
</head>
<body>

    <div id="screen-home" class="screen active">
        <h1>åœˆåéŠæˆ²</h1>
        <div class="name-input-group">
            <input type="text" id="home-player-name" placeholder="è¼¸å…¥ç©å®¶åç¨±" maxlength="10">
        </div>
        <button class="btn btn-start" onclick="startGame()">é–‹å§‹éŠæˆ²</button>
        <button class="btn btn-rank" onclick="showLeaderboard()">æ’è¡Œæ¦œ</button>
    </div>

    <div id="screen-rank" class="screen">
        <h1>å…¨çƒæ’è¡Œæ¦œ</h1>
        <div style="max-height: 400px; overflow-y: auto; width: 100%;">
            <table id="rank-table">
                <thead><tr><th>æ’å</th><th>ç©å®¶</th><th>å¾—åˆ†</th></tr></thead>
                <tbody id="rank-body"></tbody>
            </table>
        </div>
        <button class="btn btn-back" onclick="showHome()" style="margin-top: 20px;">å›ä¸»é¸å–®</button>
    </div>

    <div id="screen-game" class="screen">
        <div class="game-header">
            <div>Score: <span id="score">0</span></div>
            <div style="color: #e74c3c;">Time: <span id="timer">60</span>s</div>
        </div>
        <div id="game-canvas-container">
            <canvas id="gameCanvas" width="400" height="640"></canvas>
        </div>
        <button class="btn btn-back" onclick="triggerCanvasConfirm()" style="width: 140px; font-size: 14px; margin-top: 15px;">çµæŸéŠæˆ²</button>
    </div>

    <div id="screen-result" class="screen">
        <h1>éŠæˆ²çµæŸ</h1>
        <div class="result-score" id="final-result-score">0</div>
        <p id="result-player-display" style="margin-bottom: 20px;"></p>
        <button class="btn btn-upload" id="upload-btn" onclick="submitScore()">ä¸Šå‚³æˆç¸¾</button>
        <button class="btn btn-back" onclick="showHome()">å›ä¸»é¸å–®</button>
    </div>

<script>
    const GAS_URL = "https://script.google.com/macros/s/AKfycbywi6spIec2aA3gD9gQbDu1w-4XJZ0wy3ZDdTWGlMX33FYZtuk7kmQjN7OKxJlJHkGr/exec";
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const ROWS = 16, COLS = 10, GRID_SIZE = 40, MARGIN = 3;

    let grid = [], score = 0, timeLeft = 60, gameActive = false, isConfirmingQuit = false;
    let isDragging = false, startPos = { x: 0, y: 0 }, currentPos = { x: 0, y: 0 };
    let currentPlayerName = "ç„¡åè‹±é›„";
    let particles = [];
    const pColors = ['#f1c40f', '#e67e22', '#e74c3c', '#3498db', '#2ecc71'];

    const btnRestart = { x: 70, y: 350, w: 120, h: 40 };
    const btnQuit = { x: 210, y: 350, w: 120, h: 40 };

    let lastTime = 0, timerAccumulator = 0;
    // ğŸ’¡ é—œéµä¿®å¾©ï¼šæ–°å¢ä¸€å€‹è®Šæ•¸ä¾†å­˜æ”¾å‹•ç•«å¹€ ID
    let gameAnimationFrameId = null;

    function showScreen(id) { document.querySelectorAll('.screen').forEach(s => s.classList.remove('active')); document.getElementById(id).classList.add('active'); }
    
    // ğŸ’¡ é—œéµä¿®å¾©ï¼šå›åˆ°ä¸»é¸å–®æ™‚ï¼Œå¿…é ˆå¾¹åº•åœæ­¢éŠæˆ²é‹ç®—
    function showHome() { 
        stopGameEngine();
        showScreen('screen-home'); 
    }

    function stopGameEngine() {
        gameActive = false;
        if (gameAnimationFrameId) {
            cancelAnimationFrame(gameAnimationFrameId);
            gameAnimationFrameId = null;
        }
    }

    function startGame() {
        // å¦‚æœèˆŠçš„é‚„åœ¨è·‘ï¼Œå…ˆå¼·åˆ¶åœæ­¢
        stopGameEngine();

        currentPlayerName = document.getElementById('home-player-name').value.trim() || "ç„¡åè‹±é›„";
        localStorage.setItem('savedPlayerName', currentPlayerName);
        
        showScreen('screen-game');
        score = 0; timeLeft = 60; gameActive = true; isConfirmingQuit = false; particles = [];
        document.getElementById('score').innerText = score;
        document.getElementById('timer').innerText = timeLeft;
        initGrid();
        
        lastTime = performance.now();
        timerAccumulator = 0; // é‡ç½®æ™‚é–“ç´¯ç©å™¨
        gameAnimationFrameId = requestAnimationFrame(gameLoop);
    }

    function gameLoop(t) { 
        if (!gameActive) return; 
        
        const dt = t - lastTime; 
        lastTime = t; 
        timerAccumulator += dt; 

        if (timerAccumulator >= 1000) { 
            timeLeft--; 
            document.getElementById('timer').innerText = timeLeft; 
            timerAccumulator -= 1000; 
            if (timeLeft <= 0) { endGame(); return; } 
        } 
        render(); 
        // ğŸ’¡ ç´€éŒ„æ–°çš„ Frame ID
        gameAnimationFrameId = requestAnimationFrame(gameLoop); 
    }

    function initGrid() {
        const total = ROWS * COLS, nums = [];
        for (let i = 0; i < total / 2; i++) { let n = Math.floor(Math.random() * 9) + 1; nums.push(n, 10 - n); }
        for (let i = nums.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [nums[i], nums[j]] = [nums[j], nums[i]]; }
        grid = Array.from({ length: ROWS }, (_, r) => Array.from({ length: COLS }, (_, c) => ({ val: nums[r * COLS + c], removed: false, active: false })));
    }

    function spawnParticles(x, y) { for (let i = 0; i < 20; i++) { const ang = Math.random() * Math.PI * 2; const spd = Math.random() * 4 + 2; particles.push({ x, y, vx: Math.cos(ang) * spd, vy: Math.sin(ang) * spd, life: Math.random() * 30 + 20, size: Math.random() * 5 + 2, color: pColors[Math.floor(Math.random() * pColors.length)], type: 'dot' }); } }

    function triggerCanvasConfirm() { if (gameActive) { isConfirmingQuit = !isConfirmingQuit; } }

    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let r = 0; r < ROWS; r++) { for (let c = 0; c < COLS; c++) { if (grid[r][c].removed) continue; let x = c * GRID_SIZE + MARGIN, y = r * GRID_SIZE + MARGIN, size = GRID_SIZE - MARGIN * 2; ctx.beginPath(); ctx.roundRect(x, y, size, size, 6); ctx.fillStyle = grid[r][c].active ? '#ffbe76' : '#ffffff'; ctx.fill(); ctx.strokeStyle = grid[r][c].active ? '#e67e22' : '#f1f3f5'; ctx.lineWidth = 1.5; ctx.stroke(); ctx.fillStyle = grid[r][c].active ? '#fff' : '#2c3e50'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(grid[r][c].val, x + size/2, y + size/2); } }
        for (let i = particles.length - 1; i >= 0; i--) { let p = particles[i]; p.x += p.vx; p.y += p.vy; p.life--; ctx.globalAlpha = p.life / 60; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill(); p.vy += 0.1; if (p.life <= 0) particles.splice(i, 1); } ctx.globalAlpha = 1;
        if (isDragging && !isConfirmingQuit) { ctx.strokeStyle = '#3498db'; ctx.setLineDash([5, 3]); ctx.strokeRect(startPos.x, startPos.y, currentPos.x - startPos.x, currentPos.y - startPos.y); ctx.setLineDash([]); ctx.fillStyle = 'rgba(52, 152, 219, 0.1)'; ctx.fillRect(startPos.x, startPos.y, currentPos.x - startPos.x, currentPos.y - startPos.y); }
        if (isConfirmingQuit) { ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.roundRect(40, 250, 320, 170, 20); ctx.fill(); ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 22px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'top'; ctx.fillText('ç¢ºå®šè¦çµæŸéŠæˆ²å—ï¼Ÿ', canvas.width/2, 285); drawCanvasButton(btnRestart, '#27ae60', 'é‡æ–°é–‹å§‹'); drawCanvasButton(btnQuit, '#95a5a6', 'çµæŸéŠæˆ²'); }
    }
    function drawCanvasButton(btn, color, text) { ctx.fillStyle = color; ctx.beginPath(); ctx.roundRect(btn.x, btn.y, btn.w, btn.h, 24); ctx.fill(); ctx.fillStyle = '#fff'; ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(text, btn.x + btn.w/2, btn.y + btn.h/2); }

    canvas.addEventListener('pointerdown', (e) => {
        if (!gameActive) return;
        const rect = canvas.getBoundingClientRect();
        const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
        const my = (e.clientY - rect.top) * (canvas.height / rect.height);
        
        if (isConfirmingQuit) {
            if (isInside(mx, my, btnRestart)) startGame();
            else if (isInside(mx, my, btnQuit)) { 
                // ğŸ’¡ æŒ‰ä¸‹çµæŸæ™‚ï¼Œå‘¼å«åœæ­¢å¼•æ“å‡½å¼
                stopGameEngine();
                showHome(); 
            }
            else { isConfirmingQuit = false; }
            return;
        }
        isDragging = true; startPos = { x: mx, y: my }; currentPos = { ...startPos };
        updateActiveStates();
    });

    window.addEventListener('pointermove', (e) => {
        if (!isDragging || !gameActive || isConfirmingQuit) return;
        const rect = canvas.getBoundingClientRect();
        currentPos = { x: (e.clientX - rect.left) * (canvas.width / rect.width), y: (e.clientY - rect.top) * (canvas.height / rect.height) };
        updateActiveStates();
    });

    window.addEventListener('pointerup', () => {
        if (!isDragging) return;
        isDragging = false;
        let selected = grid.flat().filter(cell => !cell.removed && cell.active);
        if (selected.reduce((s, c) => s + c.val, 0) === 10 && selected.length > 0) {
            timeLeft += 5; document.getElementById('timer').innerText = timeLeft;
            let minC=COLS, maxC=0, minR=ROWS, maxR=0;
            grid.forEach((row, r) => row.forEach((cell, c) => { if(cell.active && !cell.removed) { minC=Math.min(minC, c); maxC=Math.max(maxC, c); minR=Math.min(minR, r); maxR=Math.max(maxR, r); } }));
            const cx = (minC + maxC + 1) * GRID_SIZE / 2, cy = (minR + maxR + 1) * GRID_SIZE / 2;
            score += selected.length * 100; document.getElementById('score').innerText = score;
            spawnParticles(cx, cy); selected.forEach(c => c.removed = true);
        }
        grid.flat().forEach(c => c.active = false);
        if (grid.flat().every(c => c.removed)) endGame();
    });

    function updateActiveStates() {
        let x1 = Math.min(startPos.x, currentPos.x), x2 = Math.max(startPos.x, currentPos.x);
        let y1 = Math.min(startPos.y, currentPos.y), y2 = Math.max(startPos.y, currentPos.y);
        for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
            let tx1 = c * GRID_SIZE, tx2 = (c+1) * GRID_SIZE, ty1 = r * GRID_SIZE, ty2 = (r+1) * GRID_SIZE;
            grid[r][c].active = !(tx2 < x1 || tx1 > x2 || ty2 < y1 || ty1 > y2);
        }
    }
    function isInside(mx, my, btn) { return mx >= btn.x && mx <= btn.x + btn.w && my >= btn.y && my <= btn.y + btn.h; }
    
    function endGame() { 
        stopGameEngine(); // ğŸ’¡ çµæŸæ™‚ä¹Ÿåœæ­¢å¼•æ“
        document.getElementById('final-result-score').innerText = score; document.getElementById('result-player-display').innerText = `Player: ${currentPlayerName}`; const b = document.getElementById('upload-btn'); b.disabled = false; b.innerText = "ä¸Šå‚³æˆç¸¾"; showScreen('screen-result'); 
    }

    async function submitScore() { const b = document.getElementById('upload-btn'); b.disabled = true; b.innerText = "ä¸Šå‚³ä¸­..."; try { const resp = await fetch(GAS_URL, { method: "POST", body: JSON.stringify({ name: currentPlayerName, score: score }) }); const ranks = await resp.json(); localStorage.setItem('math_game_rank', JSON.stringify(ranks)); alert("ğŸ‰ æˆç¸¾ä¸Šå‚³æˆåŠŸï¼"); showLeaderboard(); } catch (e) { alert("ä¸Šå‚³å¤±æ•—"); b.disabled = false; b.innerText = "é‡è©¦ä¸Šå‚³"; } }
    async function showLeaderboard() { showScreen('screen-rank'); const tbody = document.getElementById('rank-body'); tbody.innerHTML = "<tr><td colspan='3'>åŒæ­¥ä¸­...</td></tr>"; try { const resp = await fetch(GAS_URL); const ranks = await resp.json(); renderTable(ranks); } catch (e) { renderTable(JSON.parse(localStorage.getItem('math_game_rank')) || []); } }
    function renderTable(ranks) { const tbody = document.getElementById('rank-body'); if (!ranks || ranks.length === 0) { tbody.innerHTML = "<tr><td colspan='3'>æš«ç„¡ç´€éŒ„</td></tr>"; return; } tbody.innerHTML = ranks.slice(0, 10).map((r, i) => { let rankClass = "", medal = ""; if (i === 0) { rankClass = "rank-1"; medal = "ğŸ¥‡ "; } else if (i === 1) { rankClass = "rank-2"; medal = "ğŸ¥ˆ "; } else if (i === 2) { rankClass = "rank-3"; medal = "ğŸ¥‰ "; } return `<tr class="${rankClass}"><td>${medal}${i + 1}</td><td>${r.name || '-'}</td><td style="font-weight:bold">${r.score || 0}</td></tr>`; }).join(''); }

    window.addEventListener('load', () => {
        const nameInput = document.getElementById('home-player-name');
        const savedName = localStorage.getItem('savedPlayerName');
        if (savedName) nameInput.value = savedName;
        else nameInput.value = "ç„¡åè‹±é›„";
        nameInput.addEventListener('input', (e) => { localStorage.setItem('savedPlayerName', e.target.value.trim()); });
    });
</script>
</body>
</html>
